---
title: _Chirp!_ Project Report
subtitle: ITU BDSA 2025 Group `13`
author:
- "Dimitri Alessandro Nielsen <dini@itu.dk>"
- "Karl Karl Theodor Ruby <krub@itu.dk>"
- "Lukas Shaghashvili-Johannessen <lush@itu.dk>"
- "Matthias Nyman Nielsen <mnni@itu.dk>"
- "Matthias Schoenning Nielsen <mscn@itu.dk>"
numbersections: true
---

# Design and Architecture of _Chirp!_

## Domain model

## Architecture â€” In the small
Below is a onion architecture diagram to illustrate the overall architecture of the _Chirp_ application. 
The diagram also illustrates dependencies, where the outer circles depend on the inner circles.
<img width="1081" height="272" alt="OnionArchitecture" src="https://github.com/user-attachments/assets/30afb02e-f293-455d-b905-2d430731fcab" />
_Dependencies are illustrated as red arrows._

### Domain entities
In yellow is the center of the architecture as _Chirp.Core_.
This layer stores the most fundemental parts of the codebase. 
In this project _Chirp.Core_ stores the _Cheep_ and _ChirpUser_ domain model.

### Repository layer
In red is the infrastructure layer of the codebase. 
This layer is responsible for retrieving domain relevant information from the database. 

### Service layer
In orange is the service layer. 
This layer is responsible for translating the domain models into _DTO_'s (Data Transfer Object) and connect requests to the ui. 
This layer therefore acts as a binder between the infrastructure and the ui layer. 
When a user request is received the service layer handles that requests, 
retrieves information from the infrastructure layer, and translates the information received into DTO's.
These DTO's are then used by the UI to display information and data to the user.

### UI layer
In blue is the UI layer.
Here the UI is displayed to the user via `.cshmtl` pages. 
Here _page models_ sent user requests to the service layer and decide the state which to display for the user.
The state can change over the lifetime of the application, for example, when the user is logged in. 
Logging in changes the formatting of the pages, which the _page models_ are responsible for handling. 
## Architecture of deployed application

## User activities

## Sequence of functionality/calls trough _Chirp!_

# Process

## Build, test, release, and deployment
### Versioning
Our project used "Calender Versioning" in the beginning, before we were introduced to semantic versioning.
The semantic versioning was later automated for our weekly releases, using [Release Please](https://github.com/googleapis/release-please) from Google.
Release Please continously looks at the commits pushed to the main branch, and updates a changelog on a separate branch.
This changelog can then be published along with our actual release. This was done for convienece, as we can continue to develop the project without worring about creating our own changelog.

### Deployment
Whenever we deploy our code to GitHub, a number of GitHub Actions scripts will be run. These can be found the .github/workflow directory.
- coverage.yml: Runs a code coverage test and fails upon not reaching the set threshold
- format.yml: Runs dotnet format, which maintains a certain code standard in our code. These formatting commits have been attributed to our group member natthias
- main_bdsagroup13chirprazor.yml: Builds and deploys our code to our Azure Webapp instance, using our GitHub Secrets to access login information. This file was auto-generated by Azure and afterwards customized for our needs by a group member.
- release.yml: Builds and publishes our project to our GitHub repository, with builds for different operating systems.

### Linear git history
Initially, we did not enforce a linear git history as a requirement for our project, but it was a soft requirement to attempt to keep the history linear.
However, after [#87381](https://github.com/ITU-BDSA2025-GROUP13/Chirp/commit/873815545bb6ee80dd3c203ff9a895471815e3a6), we decided to enforce a linear history on the project through the git repo settings.

There are many reasons for enforcing a linear history.
For one, having a linear history makes managing and maintaining a project easier.
It is much easier to understand when a certain feature was added, as each commit is a patch, which cleanly applies atop the previous commit.

It also allows for external tools, such as ```git bisect``` to traverse the commit graph easier.
Since a linear history is just a line, it is much easier for ```git bisect``` to perform a binary search and find when a regression was introduced.
On the other hand, when the commit graph is a large interleaving of commits and merge commits, it can be difficult to perform a binary search.
This does not mean it is impossible to perform a binary search on a non-linear history, but the cognitive load on the developer is increased.

It also allows for easier code review.
Since each commit cleanly applies atop the previous, there is no extra noise generated by merge commits.
It is simply a set of patches to apply to the main branch.

Finally, one of the primary reason we used a linear git history was for external tooling.
We used an action called release-please for automated changelog generation.
This tool recommended a linear history to ease parsing of the commit graph[^release-please-linear].

The workflow for a linear git history is rather simple.
When a commit is ready to be merged with the main branch, you ```git rebase origin/main```, changes the base of the branch to be the current *HEAD* of the main branch.
This might introduce merge conflicts, which you resolve as normal.
Once the conflicts have been resolved, and the PR has been approved, it can be merged with ```git merge --ff-only```.

Having a linear git history is one way to manage a project which comes with it's set of benefits.
However, having a non-linear history has its own set of benefits.
Chiefly, some metadata is lost when a branch is rebased, since the commit the branch was initially based on has changed.
In addition to this, a non-linear history can make the history of long-lived feature branches more clear, however, since we used trunk-based development this was not a concern for us.

## Team work
### Trunk-based development

## How to make _Chirp!_ work locally

## How to run test suite locally

# Ethics

## License

## LLMs, ChatGPT, CoPilot, and others

[^release-please-linear]: [Release Please documentation about linear history](https://github.com/googleapis/release-please#linear-git-commit-history-use-squash-merge)
